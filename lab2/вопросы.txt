### 1. Принципы ООП (Объектно-Ориентированное Программирование)
   - **Инкапсуляция**: объединение данных и методов, которые с ними работают, в одном объекте. Скрытие деталей реализации и предоставление только необходимых интерфейсов.
   - **Наследование**: возможность создания новых классов на основе существующих, что позволяет повторно использовать код.
   - **Полиморфизм**: возможность использования одного интерфейса для различных типов данных, где каждый тип реализует своё поведение.
   - **Абстракция**: выделение только значимых характеристик объекта и игнорирование незначимых деталей.

### 2. Базовый класс .NET
   - Все классы в .NET наследуются от класса **`System.Object`**.

### 3. Открытые методы `System.Object`
   - **`ToString()`**: возвращает строковое представление объекта.
   - **`Equals(object obj)`**: проверяет, равен ли текущий объект другому объекту.
   - **`GetHashCode()`**: возвращает хеш-код объекта.
   - **`GetType()`**: возвращает тип текущего объекта.

### 4. Закрытые методы `System.Object`
   - **`Finalize()`**: вызывается сборщиком мусора перед уничтожением объекта (используется в деструкторах).
   - **`MemberwiseClone()`**: создает поверхностную копию объекта.

### 5. Пример определения класса
   ```csharp
   class MyClass 
   {
      public int Id { get; set; }
      public string Name { get; set; }

      public MyClass(int id, string name) 
      {
         Id = id;
         Name = name;
      }
   }
   ```

### 6. Ключевые слова при определении класса
   - **`class`**, **`public`**, **`private`**, **`protected`**, **`internal`**, **`abstract`**, **`sealed`**, **`static`**, **`partial`**.

### 7. Отличие между объектом и классом
   - **Класс** — это шаблон (схема) для создания объектов.
   - **Объект** — это экземпляр класса, который имеет свои конкретные данные.

### 8. Конструктор
   - Конструктор — это метод, который инициализирует объект класса. Он вызывается при создании объекта (при использовании ключевого слова `new`).

### 9. Свойства конструктора
   - Имя конструктора совпадает с именем класса.
   - Не возвращает значений.
   - Может быть перегружен.

### 10. Деструктор (Destructor)
   - Деструктор вызывается перед удалением объекта сборщиком мусора для очистки ресурсов. Определяется с символом `~` перед именем класса.

### 11. `this`
   - Это ключевое слово, указывающее на текущий экземпляр класса.

### 12. Пример выполнения кода
   ```csharp
   class A
   {
      private int _num;
      public A(int num) { Num = num; }
      public int Num { get { return _num; } set { _num = value; } }
   }

   static void Main(string[] args)
   {
      A a = new A(5);
      A b = a;
      Console.WriteLine(a.Num + " " + b.Num);  // 5 5

      a.Num = 7;
      Console.WriteLine(a.Num + " " + b.Num);  // 7 7
   }
   ```
   **Результат**: `5 5`, затем `7 7`, так как `a` и `b` ссылаются на один и тот же объект.

### 13. Спецификаторы доступа в C#
   - **`public`**, **`private`**, **`protected`**, **`internal`**, **`protected internal`**, **`private protected`**.

### 14. Модификатор `protected internal`
   - Член доступен в пределах текущего сборки или производных классов.

### 15. Параметры `ref` и `out`
   - **`ref`**: передает параметр по ссылке, инициализация параметра обязательна.
   - **`out`**: передает параметр по ссылке, но инициализация до передачи не требуется.

### 16. Пример необязательных и именованных параметров
   ```csharp
   void PrintInfo(string name, int age = 18)
   {
      Console.WriteLine($"{name}, {age}");
   }
   PrintInfo(age: 30, name: "John"); // Имя и возраст указаны явно
   ```

### 17. Пример полей класса
   ```csharp
   class Example
   {
      public static int StaticField = 10;
      public const int ConstantField = 100;
      public readonly int ReadonlyField = 20;

      public Example(int value)
      {
         ReadonlyField = value;
      }
   }
   ```

### 18. Пример свойств класса
   ```csharp
   class MyClass
   {
      private int _age;
      public int Age
      {
         get { return _age; }
         set { _age = value > 0 ? value : 0; }
      }
   }
   ```
   Свойства предоставляют механизм для инкапсуляции данных, контролируя доступ к полям класса.

### 19. Имя параметра метода `set`
   - Явное имя параметра — **`value`**.

### 20. Автоматические свойства
   - Это свойства, для которых компилятор автоматически создает закрытое поле.
   ```csharp
   public int MyProperty { get; set; }
   ```

### 21. Индексаторы класса
   - Позволяют классу работать как массив.
   ```csharp
   public string this[int index] { get { return array[index]; } set { array[index] = value; } }
   ```
   **Ограничение**: индексатор не может быть статическим.

### 22. Перегруженный метод
   - Это метод с тем же именем, но разными параметрами.

### 23. Partial класс
   - Позволяет разделить определение класса на несколько файлов. Это удобно для разделения кода и работы с большими проектами.

### 24. Анонимный тип
   - Тип без имени, создается на основе значений:
   ```csharp
   var person = new { Name = "John", Age = 30 };
   ```

### 25. Статические классы
   - Используются для хранения методов и свойств, которые не зависят от экземпляра класса.

### 26. Статическое поле vs Экземплярное поле
   - **Статическое поле** принадлежит классу и общее для всех его объектов.
   - **Экземплярное поле** — уникально для каждого объекта.

### 27. Работа статических конструкторов
   - Вызываются один раз, перед первым использованием статических членов класса.

### 28. Поверхностное и глубокое копирование
   - **Поверхностное копирование** копирует только ссылки на объекты.
   - **Глубокое копирование** создает полную копию объекта, включая все вложенные объекты.

### 29. Разница между равенством и тождеством объектов
   - **Равенство (`Equals`)**: сравнение значений объектов.
   - **Тождество (`==`)**: сравнение ссылок на объекты.

### 30. Частичные классы и методы
   - Позволяют разделять реализацию класса на несколько файлов. Частичные методы могут быть определены, но не обязательно реализованы.

### 31. Пример с консолью 1
   Требуется пример.

### 32. Пример с консолью 2
   Требуется пример.

### 33. Неправильный конструктор
   Требуется пример.

### 34. Аргументы конструктора
   Требуется пример.

### 35. Ошибка создания объекта класса A
   Требуется пример.

### 36. Вывод на консоль
   Требуется пример.

### 37. Ошибка компиляции
   Требуется пример.