▎1. Чем класс отличается от структуры?
- Тип данных: Классы являются ссылочными типами, а структуры — значимыми типами. Это означает, что при передаче класса передается ссылка на объект, а при передаче структуры — копия значения.
- Наследование: Классы могут наследоваться от других классов, структуры — нет. Структуры могут реализовывать интерфейсы, но не могут наследовать другие структуры или классы.
- Инициализация: Классы могут иметь конструкторы без параметров, структуры всегда инициализируются по умолчанию.
- Размер: Структуры обычно используются для хранения небольших наборов данных, в то время как классы могут использоваться для более сложных объектов.

▎2. Что может и чего не может быть в структуре?
Что может быть в структуре:
- Поля
- Свойства
- Методы
- Конструкторы
- Реализация интерфейсов

Что не может быть в структуре:
- Наследование от других структур или классов (но можно реализовать интерфейсы)
- Не может иметь явные дефолтные конструкторы (конструктор без параметров)
- Не может быть абстрактной или виртуальной

▎3. Что такое перечисление? Приведите пример определения и использования перечисления.
Перечисление (enum) — это специальный тип, который позволяет задавать набор именованных целых значений.

enum DaysOfWeek
{
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday
}

// Использование перечисления
DaysOfWeek today = DaysOfWeek.Monday;

if (today == DaysOfWeek.Monday)
{
    Console.WriteLine("Сегодня понедельник.");
}


▎4. Перечислите и поясните стандартные интерфейсы .NET.
- IEnumerable: Позволяет перебрать коллекцию.
- ICollection: Расширяет IEnumerable и добавляет методы для работы с коллекцией, такие как добавление и удаление элементов.
- IList: Расширяет ICollection и добавляет индексацию, позволяя доступ к элементам по индексу.
- IDisposable: Обеспечивает метод Dispose для освобождения ресурсов.
- IComparable: Позволяет сравнивать объекты.
- ICloneable: Позволяет создавать копии объектов.

▎5. Как используется интерфейс IComparable?
Интерфейс IComparable позволяет объектам сравнивать себя с другими объектами того же типа.

public class Person : IComparable<Person>
{
    public string Name { get; set; }
    
    public int CompareTo(Person other)
    {
        return string.Compare(Name, other.Name);
    }
}

// Использование
List<Person> people = new List<Person> { new Person { Name = "Alice" }, new Person { Name = "Bob" } };
people.Sort(); // Сортировка по имени


▎6. Как используется интерфейс ICloneable?
Интерфейс ICloneable позволяет создавать копии объектов.

public class Person : ICloneable
{
    public string Name { get; set; }

    public object Clone()
    {
        return new Person { Name = this.Name };
    }
}

// Использование
Person original = new Person { Name = "Alice" };
Person clone = (Person)original.Clone();


▎7. Что такое полиморфизм? Перечислите его формы. Приведите примеры.
Полиморфизм — это способность объектов разных классов обрабатывать один и тот же интерфейс или метод по-разному.

Формы полиморфизма:
1. Полиморфизм времени компиляции (перегрузка): Один метод может иметь несколько перегрузок с разными параметрами.
      public void Display(int number) { /* ... */ }
   public void Display(string text) { /* ... */ }
   

2. Полиморфизм времени выполнения (наследование и виртуальные методы): Один метод может быть переопределен в производном классе.
      class Animal
   {
       public virtual void Speak() { Console.WriteLine("Animal speaks"); }
   }

   class Dog : Animal
   {
       public override void Speak() { Console.WriteLine("Dog barks"); }
   }

   Animal myDog = new Dog();
   myDog.Speak(); // Вывод: Dog barks
   

▎8. Зачем в классе определяют виртуальные методы?
Виртуальные методы позволяют производным классам переопределять поведение метода, обеспечивая гибкость и возможность изменять функциональность без изменения базового класса.

▎9. Как сделать запрет переопределения методов?
Для запрета переопределения методов можно использовать ключевое слово sealed.

class BaseClass
{
    public virtual void Method() { /* ... */ }
}

class DerivedClass : BaseClass
{
    public sealed override void Method() { /* ... */ }
}

// Теперь нельзя переопределить Method в любом классе, наследующем от DerivedClass.