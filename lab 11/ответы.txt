### 1. Что такое рефлексия?

**Рефлексия** — это механизм .NET, позволяющий программе исследовать свою структуру во время выполнения. С помощью рефлексии можно:
- Получать метаинформацию о типах (классах, интерфейсах, структурах и т.д.).
- Исследовать и вызывать методы, свойства, поля, конструкторы.
- Динамически создавать экземпляры типов.
- Работать с атрибутами.

Рефлексия реализуется через классы, находящиеся в пространстве имен **`System.Reflection`**.

---

### 2. Какие есть способы получения объекта типа `Type`?

Получить объект типа `Type` можно несколькими способами:

1. **Через объект**:
   ```csharp
   Type type = obj.GetType();
   ```

2. **Через оператор `typeof`**:
   ```csharp
   Type type = typeof(ClassName);
   ```

3. **Через метод `Type.GetType()`**:
   ```csharp
   Type type = Type.GetType("Namespace.ClassName, AssemblyName");
   ```

4. **Из сборки**:
   ```csharp
   Assembly assembly = Assembly.Load("AssemblyName");
   Type type = assembly.GetType("Namespace.ClassName");
   ```

---

### 3. Охарактеризуйте классы из пространства имен `System.Reflection`

Пространство имен **`System.Reflection`** содержит классы для работы с рефлексией. Вот основные из них:

- **`Assembly`**:
  Позволяет работать с загруженными сборками (загрузка, исследование типов, ресурсов).
  
- **`Type`**:
  Хранит информацию о типе (классе, интерфейсе, структуре) — методы, поля, свойства, конструкторы.

- **`MemberInfo`**:
  Базовый класс для всех членов типа (методов, свойств, событий).

- **`MethodInfo`**:
  Содержит информацию о методе, позволяет его вызывать.

- **`FieldInfo`**:
  Содержит информацию о поле, позволяет читать/записывать значение.

- **`PropertyInfo`**:
  Содержит информацию о свойстве, позволяет читать/устанавливать значение.

- **`ConstructorInfo`**:
  Содержит информацию о конструкторе, позволяет создавать объекты.

- **`ParameterInfo`**:
  Содержит информацию о параметрах методов или конструкторов.

- **`EventInfo`**:
  Предоставляет информацию о событиях типа.

---

### 4. Как можно использовать класс `System.Type`? Перечислите его свойства и методы.

Класс **`System.Type`** используется для работы с типами. Основные возможности:
- Получение информации о методах, полях, свойствах, конструкторах, событиях.
- Проверка интерфейсов, базовых классов.
- Создание экземпляров классов.

#### Основные свойства:
- **`Name`**: Имя типа.
- **`Namespace`**: Пространство имен.
- **`Assembly`**: Сборка, в которой определён тип.
- **`BaseType`**: Базовый класс.
- **`IsAbstract`**, **`IsClass`**, **`IsInterface`**, **`IsValueType`**: Проверка типа.
- **`GenericTypeArguments`**: Генерики, применённые к типу.

#### Основные методы:
- **`GetMethods()`**, **`GetFields()`**, **`GetProperties()`**, **`GetConstructors()`**: Получение членов типа.
- **`GetInterfaces()`**: Список интерфейсов, которые реализует тип.
- **`IsSubclassOf()`**: Проверка наследования.
- **`GetCustomAttributes()`**: Список атрибутов.
- **`GetMethod()`, `GetProperty()`**: Получение конкретного метода или свойства.

---

### 5. Что такое позднее и раннее связывание?

**Раннее связывание**:
- Связывание осуществляется на этапе компиляции.
- Типы и их методы известны на момент написания кода.
- Пример:
  ```csharp
  ClassName obj = new ClassName();
  obj.Method();
  ```

**Позднее связывание**:
- Происходит на этапе выполнения.
- Используется рефлексия или динамическая типизация (`dynamic`).
- Пример:
  ```csharp
  object obj = Activator.CreateInstance(type);
  MethodInfo method = type.GetMethod("Method");
  method.Invoke(obj, null);
  ```

---

### 6. Как динамически загрузить сборку в приложение?

Для загрузки сборки динамически используется класс `Assembly`.

1. **Загрузка сборки из файла**:
   ```csharp
   Assembly assembly = Assembly.LoadFrom("path/to/assembly.dll");
   ```

2. **Загрузка сборки по имени**:
   ```csharp
   Assembly assembly = Assembly.Load("AssemblyName");
   ```

3. **Получение типа из сборки**:
   ```csharp
   Type type = assembly.GetType("Namespace.ClassName");
   ```

4. **Создание объекта**:
   ```csharp
   object obj = Activator.CreateInstance(type);
   ```

---

### 7. Что такое позднее (раннее) связывание?

Этот вопрос дублирует **вопрос №5**.

---

### 8. Для чего предназначены `BindingFlags`? Какую комбинацию флагов необходимо использовать, чтобы иметь возможность получать приватные члены класса?

**`BindingFlags`** — это перечисление, используемое для управления поведением методов рефлексии, таких как `GetMethod`, `GetField`, `GetProperty`. Оно определяет:
- Какие члены искать (публичные, приватные, статические, экземплярные).
- Способ поиска (по имени, с учётом регистра).

#### Основные значения:
- **`Public`**: Публичные члены.
- **`NonPublic`**: Приватные и защищённые члены.
- **`Static`**: Статические члены.
- **`Instance`**: Экземплярные члены.
- **`FlattenHierarchy`**: Поиск статических членов в иерархии наследования.

#### Для доступа к приватным членам:
Используйте комбинацию флагов:
```csharp
BindingFlags.NonPublic | BindingFlags.Instance
```

Пример:
```csharp
FieldInfo privateField = type.GetField("privateFieldName", BindingFlags.NonPublic | BindingFlags.Instance);
object value = privateField.GetValue(obj);
```